package com.ged.confighelper;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.sql.DataSource;

import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.ged.dao.master.OrganizationRepository;
import com.ged.domain.master.Organization;
import com.ged.util.Utils;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import liquibase.Liquibase;
import liquibase.database.Database;
import liquibase.database.DatabaseFactory;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.LiquibaseException;
import liquibase.resource.ClassLoaderResourceAccessor;

@Component
@Transactional(value = "masterTransactionManager", readOnly = true)
public class MultiTenantConnectionProviderImpl extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl
		implements ApplicationListener<ContextRefreshedEvent> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	@Inject
	private OrganizationRepository organizationRepository;

	private final static Logger LOGGER = LoggerFactory.getLogger(MultiTenantConnectionProviderImpl.class);

	private Map<String, DataSource> map; // map holds the organizationKey =>
											// DataSource

	@Value("${spring.datasource.url}")
	private String url;

	@Value("${spring.datasource.dataSourceClassName}")
	private String dataSourceClassName;

	@Value("${spring.datasource.username}")
	private String user;

	@Value("${spring.datasource.password}")
	private String password;

	@Inject
	private DataSource dataSource; // injected here to get properties and to
									// provide default.

	@PostConstruct
	public void load() {
		map = new HashMap<>();
	}

	@Override
	public void onApplicationEvent(ContextRefreshedEvent event) {
		init();
	}

	public void init() {
		for (Organization organization : organizationRepository.findAll()) {
			// in this experiment we are just using one instance of mysql. URL
			// is generated by replacing master database
			// name with company key to get new database URL
			try {
				String organizationDbUrl = url.replace(Utils.databaseNameFromJdbcUrl(url),
						organization.getOrganizationKey());
				LOGGER.debug("Configuring datasource {} {} {}", dataSourceClassName, organizationDbUrl, user);
				HikariConfig config = new HikariConfig();
				config.setDataSourceClassName(dataSourceClassName);
				config.addDataSourceProperty("url", organizationDbUrl);
				config.addDataSourceProperty("user", user);
				config.addDataSourceProperty("password", password);
				HikariDataSource dataSource = new HikariDataSource(config);
				map.put(organization.getOrganizationKey(), dataSource);
				initDbWithLiquibase(dataSource);
			} catch (Exception e) {
				LOGGER.error("Error in database URL {}", url, e);
			}
		}
	}

	private void initDbWithLiquibase(HikariDataSource dataSource) throws SQLException, LiquibaseException {
		Database database = DatabaseFactory.getInstance()
				.findCorrectDatabaseImplementation(new JdbcConnection(dataSource.getConnection()));
		Liquibase liquibase = new Liquibase("dbchangelog-product.xml", new ClassLoaderResourceAccessor(), database);
		liquibase.update("test, production");
	}

	@Override
	protected DataSource selectAnyDataSource() {
		LOGGER.debug("######### Selecting any data source");
		return dataSource;
	}

	@Override
	protected DataSource selectDataSource(String tenantIdentifier) {
		LOGGER.debug("+++++++++++ Selecting data source for {}", tenantIdentifier);
		return map.containsKey(tenantIdentifier) ? map.get(tenantIdentifier) : dataSource;
	}

}
